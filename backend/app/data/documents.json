[
    {
        "url": "https://docs.routerprotocol.com/",
        "title": "Router Docs",
        "content": "Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nThe documentation provided below pertains to Router Chain and Router Nitro. For documentation around Router Intents, please refer to the \nfollowing link\n.\nRouter Docs\nThe Router blockchain is a decentralized network built using the Cosmos SDK. Explore our docs and examples to quickly learn, develop & integrate with the Router blockchain.\nGet Started â\nBuild your first iDapp\nBuild your first iDapp (Interoperable dApp) using Router's CrossTalk in 5 simple steps.\niDapp using Stateless bridging\nBuild your first iDapp in 5 steps using Router CrossTalk's stateless bridging.\niDapp using Stateful bridging\nBuild your first Omnichain iDapp in 5 steps using Router CrossTalk's stateful bridging.\nLearn about Router\nWhat is Router?\nThe Router Chain is a layer 1 blockchain that leverages tendermintâs Byzantine Fault Tolerant (BFT) consensus engine.\nChoosing the Right Cross-chain Framework\nRouter Protocol provides a host of cross-chain solutions. Go through this guide to understand which one's right for you.\nThe ROUTE Token\nThe ROUTE token is a digital asset that will serve as the primary gas and governance token on the Router Chain.\nImportant Links\niDapps\nNitro\nAn asset transfer dApp built using Router that facilitates seamless cross-chain swaps.\nStakeEase\nAn omnichain restaking index and restaking aggregator.\nTagzz\nAn omnichain identity / domain name service.\nAuxillary Services\nRouter Explorer\nA block explorer to monitor cross-chain transactions.\nRouter Station\nA tool to manage contract lifecycle-related processes on the Router Chain.\nRouter Faucet\nA platform for users to get Router testnet tokens.\nRouter Hub\nA platform for delegating ROUTE tokens to validators.\nRouter Intent Store\nA place where developers can add their own intent adapters or explore existing ones.\nDevelopers\nð  Build iDapps using Router\nMessage Transfer\nLearn about the instruction transfer framework Crosstalk and convert your existing single/multi-chain applications to cross-chain applications.\nAsset Transfer\nLearn about asset transfer bridge Nitro and how to build other asset-transfer applications or sequenced cross-chain requests (asset + instruction)\nð  Tooling\nRouter Scan\nA feature-rich block explorer for monitoring transactions on the Router Chain.\nRouter Robot\nA cross-chain integration testing framework\nRouter Station\nA web application that makes it easier to interact with the Router Chain.\nRouter Faucet\nGet funds to interact with the Router Chain.\nRelayer\nRun a custom relayer to forward messages from Router to other chains.\nâï¸ Chain Development\nEverything that is needed to learn about development using Router's core components.\nInstalling Prerequisites\nSet up your machine to start developing on the Router Chain\nRouter CLI\nInstall routerd to join the network or simple query it.\nRouter on a Local System\nFollow the steps in this guide to run the Router blockchain on your local machine.\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/overview/",
        "title": "Introduction | Router Docs",
        "content": "Introduction | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nChoosing the Right Cross-chain Framework\nGlossary\nROUTE\nOn this page\nIntroduction\nWhat is Router Chain?\nâ\nThe Router Chain is a layer 1 blockchain that leverages tendermintâs Byzantine Fault Tolerant (BFT) consensus engine. As a Proof of Stake (PoS) blockchain, the Router Chain is primarily run by a network of validators with economic incentives to act honestly. The Router Chain is built using the Cosmos SDK and encapsulates all the features of Cosmos, including fast block times, robust security mechanisms, and, most importantly, CosmWasm - a security-first smart contract platform. By leveraging the CosmWasm toolkit, developers can start building secure blockchain applications on the Router Chain from scratch or port their existing applications to the Router Chain with minimal overhead.\nRouter Chain as an Interoperability Layer\nâ\nIn addition to its functionalities as a blockchain network, the Router Chain provides an innovative\nsolution to the problem of blockchain interoperability. Apart from validating state changes on the Router\nchain, validators running on the Router Chain can also monitor state changes on other chains. Applications\non the Router Chain can write custom logic to trigger events in response to these external state changes.\nAdditionally, applications on the Router Chain can leverage a trustless network of relayers to update\nstates on external chains. Simply put, the Router architecture allows contracts on one chain to interact\nwith contracts on other chains in a secure and decentralized manner. \nCommunication via Router CrossTalk\nâ\nRouter's CrossTalk library is an extensible cross-chain framework that enables seamless state transitions across multiple chains. In simple terms, this library abstracts Router's functionalities to allow contracts on one chain to pass instructions to contracts deployed on some other chain. The library is structured in a way that it can be integrated seamlessly into your development environment to allow for cross-chain message passing without disturbing other parts of your product. \nCrossTalk supports both stateful and stateless bridging:\nFor cross-chain dApps that require custom bridging logic between any two chains, developers can build and deploy middleware contracts on the Router Chain. All cross-chain requests originating from the dApp's source chain contract will come to this middleware contract where some actions can be performed before they are forwarded to the intended destination chain.\nFor dApps that do not require any custom bridging logic or any data aggregation layer in the middle, no middleware contract is required. \nGlobal Liquidity via Nitro\nâ\nNitro is a cross-chain swapping engine that allows for cross-chain asset transfers as well as cross-chain sequencing of asset transfers and arbitrary instruction transfers. Nitro has a whole development suite around it, which includes:\na widget that can be used by other projects to give their users an option to perform cross-chain transactions directly from their UI;\nan API and a SDK that abstracts Nitro's backend capabilities for projects that want to use their own UI/platform for offering the cross-chain asset swap functionality;\nmost importantly, the sequencer library, which allows developers to build cross-chain applications that require both asset transfer and instruction transfer in a single cross-chain request.\nEdit this page\nNext\nChoosing the Right Cross-chain Framework\nWhat is Router Chain?\nRouter Chain as an Interoperability Layer\nCommunication via Router CrossTalk\nGlobal Liquidity via Nitro\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/router-core/",
        "title": "Introduction | Router Docs",
        "content": "Introduction | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInstalling Prerequisites\nRouter CLI\nRunning Router Chain on Any Local System\nGuides\nOn this page\nIntroduction\nThe guides in this section will explain the process of developing using Router's core components.\nGet Started\nâ\nDevelopers\nInstalling Prerequisites\nSetting up the machine for developing on the Router Chain\nRouter CLI\nInstall routerd to join the network or simple query it\nRouter on a Local System\nRun the Router blockchain on your local machine\nGuides\nYour First Contract\nLearn how to compile and deploy your first CosmWasm contract on the Router Chain\nEdit this page\nNext\nInstalling Prerequisites\nGet Started\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/develop/",
        "title": "Introduction | Router Docs",
        "content": "Introduction | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nMessage Transfer via CrossTalk\nAsset Transfer via Nitro\nOn this page\nIntroduction\nThe guides on this page will explain the process of developing via Router's CrossTalk and Nitro. The CrossTalk framework\nleverages Router's infrastructure to allow contracts on one chain to send intructions to contracts deployed on some other chain. On the other hand,\nNitro is the native cross-chain asset-transfer bridge built using Router. It acts as the gateway to the liquidity managed by Router Protocol and allows\nprojects to execute cross-chain transactions which involve both fund transfer and instruction transfer.\nIf you're new here or you're not sure if CrossTalk is compatible with your requirements, check out \nthis guide\n to figure out\nthe best cross-chain framework for your dApp.\nMessage Transfer via CrossTalk\nâ\nTheoretical Concepts\nOverview\nWhat is CrossTalk why is it required?\nUnderstanding Message transfer\nDissecting different functions and parameters associated with CrossTalk\nFee Management\nGaining a deeper understanding of how the CrossTalk and Omnichain Fee is computed\nGuides\nEVM Guides\nLearning how to execute different types of cross-chain requests in EVM Chains\nNEAR Guides\nLearning how to execute different types of cross-chain requests in NEAR\nRouter Chain Guides\nLearning how to execute different types of cross-chain requests from or to Router Chain\nSample iDapps\nDeploying a Cross-chain Ping Pong Contract\nLearn how to deploy your first cross-chain dApp using Router's CrossTalk framework\nDeploying a Cross-chain NFT (ERC-1155)\nLearn how to deploy a cross-chain NFT using Router's CrossTalk framework\nUnderstanding Functions\nEVM\nUnderstanding the crosstalk functions for EVM contracts\nNEAR\nUnderstanding the crosstalk functions for Near chain\nRouter Chain\nUnderstanding the crosstalk functions for Router Chain\nAsset Transfer via Nitro\nâ\nDevelopers\nOverview\nWhat is Nitro and how is it different from Voyager?\nRouter Nitro\nUnderstanding the architecture of Nitro\nDevelopers\nNitro Widget\nWidget to integrate cross-chain swaps on your website\nNitro PathFinder API\nAn API to integrate Voyager's cross-chain swap functionality\nMigrating from Voyager to Nitro\nGuide to help users migrate from Voyager to Nitro\nGuides\nDeploying a Cross-chain Staking Contract using Nitro\nLearn how to deploy your first cross-chain staking dApp using Nitro\nBuilding a Cross-chain Token using Router\nLearn how to deploy a cross-chain token using Router\nCross-chain Transfer/Swap APIs\nAPI endpoints\nNitro Pathfinder API endpoints\nGetting Started\nHow to interact with Pathfinder API\nEdit this page\nNext\nMessage Transfer via Crosstalk\nMessage Transfer via CrossTalk\nAsset Transfer via Nitro\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/router-pay/",
        "title": "Introduction | Router Docs",
        "content": "Introduction | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nIntegrating Router Pay\nUser Journey with Router Pay\nTechnical Specifications\nBenefits\nIntroduction\nRouter Pay introduces the Instruction Specific Address (ISA) mechanism, which enables wallet-less interactions with decentralized applications (DApps). By generating dynamic, single-use addresses, users can initiate transactions by transferring assets directly, without wallet connections or approvals. The ISA mechanism supports both single-chain and cross-chain interactions, enhancing user security and convenience while bringing a familiar Web 2.0 experience to Web 3.0 applications, including use cases like POS machines for merchant payments.\nMotivation\nCurrently, DApp interactions in Web 3.0 often require wallet connections and approvals, introducing additional steps that disrupt usability and pose security risks. This complex flow has hindered DeFi adoption, as Web 3.0 interfaces donât match the ease and familiarity of Web 2.0 experiences, especially compared to centralized exchanges.\nRouter Pay (referred to as ISA as well) addresses these issues by offering a user journey that mirrors the simplicity of Web 2.0 actions. With Router Pay, users can complete interactions by simply scanning a QR code and sending payment. This approach enables a seamless, recognizable process, supporting a Web 2.0-like user experience in a Web 3.0 setting. By bridging the usability gap between centralized and decentralized applications, Router Pay opens the door for greater mainstream adoption of DeFi.\nLearn about Router Pay\nUser Journey with Router Pay\nLearn about the advanced user journey with Router Pay\nTechnical Specifications\nHow does Router Pay work technically\nBenefits\nBenefits of Router Pay\nIntegrating Router Pay\nAPI endpoints\nRouter Pay API endpoints\nAdd ISA to your dApp\nIntegrate Router Pay and provide a no sign-up UX to users\nNitro integration via Router Pay\nIntegrate Router Nitro with no sign-up flow for users\nEdit this page\nNext\nIntegrating Router Pay\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/tooling/",
        "title": "Introduction | Router Docs",
        "content": "Introduction | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInfrastructure\nUtilities\nRelayers\nNitro Forwarders\nOn this page\nIntroduction\nThe guides in this section will explain the process of using various tools to simplify building and maintaining dApps using Router.\nImportant Tools\nâ\nRouter Explorer\nA block explorer to monitor cross-chain transactions.\nRouter Faucet\nA tool to get testnet tokens for performing tasks on Testnet.\nRouter Station\nA tool to manage contract lifecycle-related processes on the Router Chain.\nRouter Hub\nA tool for delegating ROUTE tokens to validators.\nRouter Sandbox\nAn easy-to-use prototyping environment for interoperable dApps built using Router.\nInfrastructure\nâ\nRouter Scan\nA block explorer for projects to monitor their cross-chain transactions\nRouter Station\nA tool to manage contract lifecycle-related processes on the Router Chain\nRouter Robot\nA cross-chain integration testing framework\nRouter Sandbox\nAn easy-to-use prototyping environment for interoperable dApps built using Router\nUtilities\nâ\nGolang SDK\nA Go SDK to interact with the Router Chain\nTypescript SDK\nA TS SDK to interact with the Router Chain\nRouter Wasm Bindings\nA Rust crate consisting of wasm bindings to create contracts on the Router Chain\nRelayers\nâ\nOverview\nBasics about relayers on the Router Chain\nRelayer Guide\nSteps involved in running a relayer\nEdit this page\nNext\nInfrastructure\nImportant Tools\nInfrastructure\nUtilities\nRelayers\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/networks/",
        "title": "Public Endpoints | Router Docs",
        "content": "Public Endpoints | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nPublic Endpoints\nSupported Chains\nTools\nOn this page\nPublic Endpoints\nThe following APIs are recommended for development purposes.\nOfficial Public Endpoints\nâ\nNetwork\nMainnet\nTestnet\nChain ID\nrouter_9600-1\nrouter_9601-1\nRPC\nhttps://sentry.evm.rpc.routerprotocol.com\nhttps://evm.rpc.testnet.routerchain.dev\ngRPC-gateway\nhttps://sentry.grpcweb.routerprotocol.com\nhttps://grpc.testnet.routerchain.dev\nTM endpoint\nhttps://sentry.tm.rpc.routerprotocol.com\nhttps://tm.rpc.testnet.routerchain.dev\nLCD endpoint\nhttps://sentry.lcd.routerprotocol.com\nhttps://lcd.sentry.routerchain.dev\nFaucet UI\n-\nhttps://faucet.routerprotocol.com\nExplorer UI\nhttps://routerscan.io\nhttps://testnet.routerscan.io\nExplorer endpoint\nhttps://api.explorer.routerscan.io\nhttps://explorer-api.testnet.routerchain.dev\nExplorer WSS endpoint\nwss://api.explorer.routerscan.io\nwss://explorer-api.testnet.routerchain.dev\nEdit this page\nNext\nSupported Chains\nOfficial Public Endpoints\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/validators/",
        "title": "Overview | Router Docs",
        "content": "Overview | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nOverview\nOrchestrators\nPoS Validation\nSupported Networks\nRunning a Validator\nDelegating ROUTE Tokens to Participate in Staking\nSlashing Conditions\nOverview\nValidators are nodes that participate in the security of a network by verifying and committing new blocks in the blockchain. Like other Cosmos-based chains, validators on the Router Chain are expected to mine blocks in exchange for block rewards. However, validators on the Router Chain are tasked with another responsibility - running an orchestrator instance. Before reading more about orchestrators, it is important to understand the \nhigh-level workflow\n of a cross-chain transaction via Router.\nEdit this page\nNext\nOrchestrators\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/discover/",
        "title": "Discover iDapps and Tools | Router Docs",
        "content": "Discover iDapps and Tools | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nDiscover iDapps and Tools\nOn this page\nDiscover iDapps and Tools\nThis section provides an overview of the different iDapps developed using Router's infrastructure. Additionally, you can access essential tools required for interacting with Router's infrastructure.\niDapps\nâ\nNitro\nAn asset transfer dApp built using Router that facilitates seamless cross-chain swaps.\nStakeEase\nAn omnichain restaking index and restaking aggregator.\nTagzz\nAn omnichain identity / domain name service.\nTools\nâ\nRouter Explorer\nA block explorer to monitor cross-chain transactions.\nRouter Station\nA tool to manage contract lifecycle-related processes on the Router Chain.\nRouter Faucet\nA platform for users to get Router testnet tokens.\nRouter Hub\nA platform for delegating ROUTE tokens to validators.\nRouter Intent Store\nA place where developers can add their own intent adapters or explore existing ones.\nEdit this page\niDapps\nTools\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/brand-assets/",
        "title": "Brand Assets | Router Docs",
        "content": "Brand Assets | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nBrand Assets\nRouter Brand Assets\nNitro Brand Assets\nBrand Assets\nWelcome to the Router Protocol Brand Kit!\nHere, you'll find all the assets and logos you need to represent Router Protocol consistently and accurately across all mediums. Our goal is to enable builders to create seamless, user-friendly chain abstracted dApps that connect all chains, and our branding reflects that vision of simplicity and connectivity.\nBelow are the brand assets for both Router Protocol and Nitro.\nRouter Brand Assets\nNitro Brand Assets\nEdit this page\nNext\nRouter Brand Assets\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/develop/message-transfer-via-crosstalk/evm-guides/your-first-crosschain-nft-contract/",
        "title": "Your First iDapp | Router Docs",
        "content": "Your First iDapp | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nMessage Transfer via CrossTalk\nOverview\nKey Concepts\nEVM Guides\niDapp Functions\nBuild your first Cross-Chain NFT contract\nCreating a Sample Cross-Chain NFT Contract\nDeploying a Sample Cross-Chain NFT Contract\nCross-chain Read Requests\nASM Implementation\nNEAR Guides\nRouter Chain Guides\nSolana Guides\nStateful (OmniChain) Bridging\nSample iDapps\nHelpful Repositories\nAsset Transfer via Nitro\nYour First iDapp\nIn this section, we'll provide a step-by-step guide for how users can deploy their first iDapp using the Crosstalk framework.\nThe iDapp end-to-end development is a simple 5 step process. It has been broken down into 2 parts -\nCreating your cross-chain NFT contract\nDeploying and testing your NFT contract\nEdit this page\nPrevious\nsetDappMetadata\nNext\nCreating a Sample Cross-Chain NFT Contract\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/develop/message-transfer-via-crosstalk/stateful-bridging/your-first-omnichain-dapp/",
        "title": "Your First OmniChain dApp | Router Docs",
        "content": "Your First OmniChain dApp | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nMessage Transfer via CrossTalk\nOverview\nKey Concepts\nEVM Guides\nNEAR Guides\nRouter Chain Guides\nSolana Guides\nStateful (OmniChain) Bridging\nYour First Omnichain dApp\n1) Setting up Router's EVM Tesnet\n2) Deploying a Sample Application Contract\n3) Deploying a Sample Bridge Contract\nStateful vs Stateless Bridging\nBenefits\nHigh Level Architecture\nTexchange\nSample iDapps\nHelpful Repositories\nAsset Transfer via Nitro\nYour First OmniChain dApp\nIn this section, we'll provide a step-by-step guide for how users can deploy their first cross-chain dApp that leverages the middleware infra enabled by the Router Chain.\nBefore diving into the guide, it's important to understand Router's \nhigh-level architecture\n. Once you have gained a basic understanding of how a cross-chain application works on the Router Chain, you can read through this guide that will cover the following sections:\nSetting up Router's EVM Devnet to deploy and test sample cross-chain applications\nDeploying a sample application contract (Solidity) on Router's EVM Devnet\nDeploying a sample bridge contract (CosmWasm) on Router's Alpha Devnet\nAt the end of the guide, we'll have two working contracts:\nAn application contract on Router's EVM Devnet acting as both the source and destination contract\nA bridge contract on the Router Chain\nEdit this page\nPrevious\nStateful (OmniChain) Bridging\nNext\n1) Setting up Router's EVM Tesnet\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/overview/choosing-the-right-framework/",
        "title": "Choosing the Right Cross-chain Framework | Router Docs",
        "content": "Choosing the Right Cross-chain Framework | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nChoosing the Right Cross-chain Framework\nGlossary\nROUTE\nOn this page\nChoosing the Right Cross-chain Framework\nRouter Protocol provides two ways using which developers can build cross-chain applications, namely -\nCrossTalk framework (stateless and stateful communication)\nNitro (leveraging global liquidity with message transfers)\nLet us now understand which framework best suits your requirements before using it in your dApp. \nCrossTalk Framework\nâ\nStateless\nâ\nFor standard cross-chain instruction transfers, CrossTalk framework is the best option. It is an easy-to-implement cross-chain smart contract library that can convert your existing multi-chain applications to cross-chain applications. CrossTalk's ability to transfer multiple contract-level instructions in a single cross-chain call makes it a very powerful tool. Various dApps like cross-chain NFTs (burning an NFT on one chain and minting it on another) and cross-chain lending/borrowing applications (enabling a borrower to provide collateral on one chain and then transferring an instruction to mint/unlock the borrower's desired token on the destination chain) can be built using this framework.\nStateful\nâ\nIf an application does not require any logic in the middle or does not need any accounting layer, CrossTalk's generic workflow can be used. However, if you want to build an application that requires custom bridging logic or a decentralized accounting layer, you can use CrossTalk's stateful bridging. For example, you can use stateful bridging to create a multi-chain NFT collection with a single place to maintain the list of all the NFTs minted on different chains. If you wanted to use existing solutions, you'd have to maintain this list on all the chains where your dApp is deployed. In this case, by removing the redundancy involved in accounting, a CosmWasm contract on the Router Chain act as a data aggregation layer. Another potential dApp that can benefit from Router's middleware capabilities is a cross-chain DEX. You'll need to deploy the token-swapping logic only on the Router Chain, while smart contracts on other chains only need to include the locking/unlocking logic. \nNitro\nâ\nNitro (previously Voyager) is the native cross-chain asset-transfer bridge built on Router. It acts as the gateway to the liquidity managed by Router Protocol. Developers can use Nitro to access this liquidity and build either (a) other asset-transfer applications or (b) applications requiring both an asset transfer and an instruction transfer in a single sequenced cross-chain request. A very good example of the latter is a cross-chain staking application that needs to transfer users' funds and an instruction to stake them in a particular contract, both in a single cross-chain request.\nEdit this page\nPrevious\nIntroduction\nNext\nGlossary\nCrossTalk Framework\nNitro\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/overview/route/",
        "title": "ROUTE | Router Docs",
        "content": "ROUTE | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nChoosing the Right Cross-chain Framework\nGlossary\nROUTE\nOn this page\nROUTE\nRouter Protocol's native cryptographically-secured digital token ROUTE is a transferable representation of a functional asset that will be used as the gas and governance token in the Router ecosystem. \nUtility\nâ\nROUTE will initially be used for the following (although governance is free to add or remove these functions):\nGovernance\nâ\nThe holders of the ROUTE token will be able to use their tokens to decide the future of the protocol by voting on Router's governance proposals. Active stakeholders of the network will be responsible for proposing, vetting, and passing proposals concerning protocol amendments and upgrades.\nGas Currency\nâ\nROUTE token will be used as the native token on the Router Chain. \nValidator Incentives\nâ\nBlock rewards to the validators will be paid out in ROUTE tokens.\nCrossTalk Fees\nâ\nROUTE token will be used as a fee token in Routerâs CrossTalk framework.\nEdit this page\nPrevious\nGlossary\nUtility\nGovernance\nGas Currency\nValidator Incentives\nCrossTalk Fees\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/develop/message-transfer-via-crosstalk/",
        "title": "Message Transfer via Crosstalk | Router Docs",
        "content": "Message Transfer via Crosstalk | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nMessage Transfer via CrossTalk\nOverview\nKey Concepts\nEVM Guides\nNEAR Guides\nRouter Chain Guides\nSolana Guides\nStateful (OmniChain) Bridging\nSample iDapps\nHelpful Repositories\nAsset Transfer via Nitro\nMessage Transfer via Crosstalk\nThis section of the documentation will provide an in-depth view of the CrossTalk framework.\nTheoretical Concepts\nOverview\nWhat is CrossTalk why is it required?\nKey Concepts\nDissecting different functions and parameters associated with CrossTalk\nFee Management\nGaining a deeper understanding of how the CrossTalk and Omnichain Fee is computed\nGuides\nEVM-Guides\nLearning how to execute different types of cross-chain requests in EVM Chains\nNEAR-Guides\nLearning how to execute different types of cross-chain requests in NEAR\nSolana-Guides\nLearning how to execute different types of cross-chain requests from or to Solana\nRouter-chain-Guides\nLearning how to execute different types of cross-chain requests from or to Router Chain\nSample iDapps\nDeploying a Cross-chain Ping Pong Contract\nLearn how to deploy your first cross-chain dApp using Router's CrossTalk framework\nDeploying a Cross-chain NFT (ERC-1155)\nLearn how to deploy a cross-chain NFT using Router's CrossTalk framework\nUnderstanding Functions\nEVM Guide\nUnderstanding the crosstalk functions for EVM contracts\nNEAR Guide\nUnderstanding the crosstalk functions for Near chain\nSolana Guide\nUnderstanding the crosstalk functions for Solana\nRouter Chain Guide\nUnderstanding the crosstalk functions for Router Chain\nEdit this page\nPrevious\nIntroduction\nNext\nOverview\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/tooling/infra/router-scan/",
        "title": "RouterScan | Router Docs",
        "content": "RouterScan | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInfrastructure\nRouter Scan\nFetch data using GQL Playground\nFetch data using JS\nApplication-specific Explorer\nRouter Station\nRouter Sandbox\nRouter Robot\nUtilities\nRelayers\nNitro Forwarders\nOn this page\nRouterScan\nOverview\nâ\nThe Router explorer provides information on the blocks, validator, network status, and various types of transactions happening on Router Chain. We have provided an easy way using GraphQL to query the Router Chainâs explorer data so that developers and applications can use the data as per their requirements for analytics or creating their own custom explorer.\nAPI Endpoints\nâ\nHere all requests are READ ONLY. As of now there are no updates on DB available using these APIs. There are multiple endpoints provided, which can be used to get the desired data.\nExplorer DBâs data can be queried with the GraphQL endpoints as given below. For application specific use cases refer \nApplication specific explorer\n \nIn case of a requirement to directly use the functions to get data rather than a query, \nsdk-ts\n can be used. The SDK has all the necessary function to query data from the explorer DB.\nEdit this page\nPrevious\nInfrastructure\nNext\nFetch data using GQL Playground\nOverview\nAPI Endpoints\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/tooling/infra/router-robot/",
        "title": "Overview | Router Docs",
        "content": "Overview | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInfrastructure\nRouter Scan\nRouter Station\nRouter Sandbox\nRouter Robot\nOverview\nUsage\nUtilities\nRelayers\nNitro Forwarders\nOn this page\nOverview\nWhat is Router Robot?\nRouterRobot is a cross-chain integration testing framework for end-to-end testing, behavior-driven development (BDD), and robotic process automation (RPA). The framework has a rich ecosystem around it consisting of various generic libraries and tools that are developed to ease e2e testing of cross-chain applications built on the Router Chain.\nWhy Router Robot?\nâ\nEnables easy-to-use tabular syntax for \ncreating test cases\n in a uniform way.\nProvides ability to create reusable \nhigher-level keywords\n from existing keywords.\nProvides easy-to-read result \nreports\n and \nlogs\n in HTML format.\nIs platform and application independent.\nProvides a simple \nlibrary API\n for creating customized test libraries that can be implemented natively with Python.\nProvides a \ncommand line interface\n and XML-based \noutput files\n for integration into existing build infrastructure (continuous integration systems).\nProvides support for testing web applications, rest APIs, mobile applications, running processes, connecting to remote systems via Telnet or SSH, and so on.\nSupports creating \ndata-driven test cases\n.\nHas built-in support for \nvariables\n, practical, particularly for testing in different environments.\nProvides \ntagging\n to categorize and \nselect test cases\n to be executed.\nEnables easy integration with source control: \ntest suites\n are just files and directories that can be versioned with the production code.\nProvides \ntest-case\n and \ntest-suite-level\n setup and teardown.\nEdit this page\nPrevious\nRouter Robot\nNext\nUsage\nWhy Router Robot?\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/tooling/infra/router-station/",
        "title": "Router Station | Router Docs",
        "content": "Router Station | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInfrastructure\nRouter Scan\nRouter Station\nRouter Sandbox\nRouter Robot\nUtilities\nRelayers\nNitro Forwarders\nOverview\nRouter Station is the official tool of the Router Chain. It helps with wallet management, cosmwasm contract deployment, execution, queries, and other contract lifecycle-related processes.\nTo deploy a smart contract on the Router Chain there is a requirement to create a wasm build of the smart contract. \nPlease refer to the following document to learn how to create the wasm build.\n1. Add a Router Account on the Router Station\nTo use the Router Station UI for any operation related to the contract life-cycle process( except the contract read query), you need to have at least one account added in the Router Station. To add an account in the Router Station, you need to follow the below mentioned steps or you can also follow the video. \nClick on the âAdd Accountâ button\nIn the pop-up, fill the âLabelâ & âMnemonicâ text areas. You can also click on the refresh button to get a new Mnemonic.\nNow, click on the âAddâ button. and your account is added to the Router Station.\nYou can follow the same process for multiple accounts here.\n2. Add an existing smart contract\nYou can add an existing cosmwasm contract in the Router Station. To add an existing contract address, you need to click on the â+Add contractâ button.  A pop-up shows up. The router contract address can be added in the Import contract text field and can be imported for further action.\n3. Upload wasm Contract\nThe Router Chain is a cosmos chain. To deploy a smart contract first, you need to upload the contractâs wasm file on the chain. On Router Station to upload a wasm file, you need to follow the below mentioned steps or you can also follow the video. \nClick on the â+Add Contractâ button. It will open up one pop-up.\nHere, you need to select the wasm file.\nThen click on the âUpload Onlyâ button.\nOnce the upload button is clicked an \nUploading Contract\n toast msg can be seen, which signifies that the contract upload is happening in the background.\nAfter the successful transaction, a success toast message can be seen with the \nUploaded code Id\n to the right. \n4. Upload wasm contract and Instantiate\nIn Router Chain, you can create a new contract by instantiating a deployed code id. If you donât have a deployed code id preset then you can deploy and instantiate the contract otherwise instantiate the contract by using the existing deployed code id.\nYou provide both functionalities on the Router Station. \nTo deploy and instantiate a smart contract first, you need to follow the below mentioned steps or you can also follow the video. \nClick on the â+Add Contractâ button. It will open up one pop-up.\nFirst, you need to select the âFrom fileâ radio button.\nYou need to fill the âLabelâ text box and instantiate the message.\nThe admin field is optional. If it is empty our admin will be null and that makes the contract immutable.\nHere, you also need to select the wasm file.\nThen click on the âUpload and Instantiateâ button.\nOnce the upload and instantiate button is clicked upon, an \nUploading Contract\n toast message can be seen. This signifies that the uploading of the contract is happening in the background.\nRight after uploading is successful, the uploaded contractâs code id and instantiating contract toast msg can be seen. This signifies that the instantiation of the contract is happening in the background. \nAfter successful instantiation of the contract, a success toast with the instantiated contract address can be seen, in it to the right and that particular contract added on to the left side under the Contracts section can be seen.\n5. Execute transaction  and Query operation on the added contract\nA cosmwasm contract has multiple execute or query messages. The execute message can read and write the contract states, but the query messages can only read contract storage. That is why to perform execute messages you need to have a user account, but not for the query messages.\nIn the Router station, you need to select one contract on which you want to perform the operation. Then you can write down the JSON query in the text section as shown in the video. Now, according to the query type you can hit either the âExecuteâ or the âqueryâ button.  The output will be shown in the right section of the query.\nPlease check out the video, In this video, you performed the message execution and query for the Counter contract. link?\n6. Contract Migration\nCosmwasm contracts can be upgraded. To upgrade a cosmwasm smart contract, you need to satisfy two conditions. The contract should support migration and its admin address should not be null. To migrate the contract, you need to follow the below mentioned steps or you can also follow the video. \nSelect the contract that needs to be migrated.\nClick on the âMigrate Contractâ button. It will open one pop-up.\nProvide the new code id and the âmigration messageâ.\nNow, Click on the âmigrateâ button. It will submit the migration message on the chain.\nUpon, the successful transaction you will able to see the updated code id in the contract info section.\n7. Contract Admin Update\nCosmwasm contracts have an admin address. It is provided at the time of instantiation of the contract. It decides the contractâs immutability. If it is null, the contact is immutable. \nTo update the contractâs admin address, you need to follow the below mentioned steps or you can also follow the video. \nSelect the contract that needs to be updated.\nClick on the âUpdate Adminâ button. It will open one pop-up.\nProvide the new admin address or leave it empty( if you want to set the admin address to null).\nNow, Click on the âupdateâ button. It will submit the update admin message on the chain.\nUpon, the successful transaction you will able to see the updated admin address in the contract info section.\nEdit this page\nPrevious\nUsage\nNext\nRouter Sandbox\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/tooling/relayers/",
        "title": "Overview | Router Docs",
        "content": "Overview | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInfrastructure\nUtilities\nRelayers\nOverview\nRelayer Guide\nNitro Forwarders\nOn this page\nRelayers\nBasics about relayers on the Router Chain\nIntro to Router Relayers\nâ\nIn the Router system, relayers are permissionless entities that relay executable proposals from the Router Chain to a specific\ndestination chain. The Router Chain has a set of relayers operated by various third parties, which distributes the\nresponsibility. In the set, each relayer listens to the Router Chain and relays data to the\ndestination chains as and when required. These relayers also carry out subsequent actions based on the\nevents that have been transmitted.\nFunctionalities\nâ\nThe relayer will be able to submit outbound/crosstalk requests to the destination chain.\nThe relayer will be able to whitelist application bridge contract addresses and process only outbound requests originating from the whitelisted application bridge contract addresses.\nThe relayer will be able to submit a ValsetUpdate request to all the destination chains configured\non the multichain module.\nThe relayer will be able to secure the keys of various chain types - EVM, Cosmos, and Substrate,\namong others.\nEdit this page\nPrevious\nRelayers\nNext\nRelayer Guide\nIntro to Router Relayers\nFunctionalities\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/router-core/installing-prerequisites/",
        "title": "Installing Prerequisites | Router Docs",
        "content": "Installing Prerequisites | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInstalling Prerequisites\nRouter CLI\nRunning Router Chain on Any Local System\nGuides\nOn this page\nInstalling Prerequisites\nInstall Go\nâ\nIf you do not have Go installed in your system, you can set it up by following the three easy steps listed \nhere\n. The latest versions of \nrouterd\n require Go version \nv1.18+\n.\nSet up Rust\nâ\nTo work with CosmWasm, you'll need to make sure you have \nrustup\n installed along with a recent \nrustc\n and \ncargo\n version installed. Currently, we are testing on \n1.58.1+\n. We use \nrustup\n to install rust since it makes maintaining dependencies and handling updates much more efficient.\nInstalling Rust on Mac/Linux\nStep 1)\n Install \nrustup\n.\nStep 2)\n Once installed, check that you have the correct version installed:\nrustup default stable\ncargo version\n# If this is lower than 1.58.1+, update\nrustup update stable\nStep 3)\n Once rust is installed, make sure you have the \nwasm32\n target:\nrustup target list --installed\n# if wasm32 is not listed after running the aforementioned command, run the following:\nrustup target \nadd\n wasm32-unknown-unknown\nInstalling Rust on Windows 10\nStep 1)\n Download and execute \nrustup-init.exe\n from \nrustup.rs\n.\nIf prompted, download and install Visual C++ Build Tools 2019, from \nhttps://visualstudio.microsoft.com/visual-cpp-build-tools/\n. Make sure \"Windows 10 SDK\" and \"English language pack\" are selected.\nStep 2)\n Once installed, check that you have the correct version installed:\nrustup default stable\ncargo version\n# If this is lower than 1.58.1+, update\nrustup update stable\nStep 3)\n Once rust is installed, make sure you have the \nwasm32\n target:\nrustup target list --installed\n# if wasm32 is not listed after running the aforementioned command, run the following:\nrustup target \nadd\n wasm32-unknown-unknown\nIDE\nâ\nTo develop and test smart contracts using Rust, a good IDE is a must. Currently, \nVSCode\n is the best-supported environment for RLS (Rust Language Server). Coupled with the \nrust-analyzer for the VSCode\n plugin, it makes use of the rust compiler to type-check all your code on each save.\nDocker\nâ\nTo optimize production code and make the binary size of compiled CosmWasm contracts as small as possible, we use \nrust-optimizer\n, which uses Docker to work. Download and install Docker Desktop for your system using this \nlink\n.\nEdit this page\nPrevious\nIntroduction\nNext\nRouter CLI\nInstall Go\nSet up Rust\nIDE\nDocker\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/router-core/routerd/",
        "title": "Router CLI | Router Docs",
        "content": "Router CLI | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInstalling Prerequisites\nRouter CLI\nRunning Router Chain on Any Local System\nGuides\nOn this page\nrouterd\nrouterd\n is the command-line interface and daemon that connects to Router and enables you to interact with the Router Chain. Router Core is the official Golang reference implementation of the Router node software.\nQuick Start\nâ\nTo install \nrouterd\n and interact with the Router Core without running a node, run the following commands on your terminal/cmd:\ngit\n clone https://github.com/router-protocol/router-chain.git\n//router-chain.git is a private repo as of now, please request access \nfor\n the same via discord\ncd\n router-chain\ngit\n checkout dev\nmake\n \ninstall\nVerify the installation by running the following command:\nrouterd version\nTroubleshooting Common Issues\nIf you are on a Windows machine and the \nmake\n software is not preinstalled, install it using the instructions given \nhere\n.\nIf you get the following error while cloning the router-chain git repo: \nremote: Support for password authentication was removed on August 13, 2021\n then follow the steps given \nhere\n to resolve it.\nIf you get the following error while running \nmake install\n on your Mac: \nxcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun\n then follow the steps given \nhere\n to resolve it.\nmake install\n will copy \nrouterd\n to \n$HOME/go/bin\n by default. If you get the following error: \nzsh: command not found: routerd\n then add the following two commands to the ~/.zshrc file:\nexport\n \nGOPATH\n=\n$HOME\n/go\nexport\n \nPATH\n=\n$GOPATH\n:\n$GOPATH\n/bin:\n$PATH\nTo find the ~/.zshrc file, go to Finder -> Home (your Mac user account) and unhide hidden files by pressing \ncmd\n + \nshift\n + \n.\n simultaneously.\nEdit this page\nPrevious\nInstalling Prerequisites\nNext\nRunning Router Chain on Any Local System\nQuick Start\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
    {
        "url": "https://docs.routerprotocol.com/router-core/running-router-chain-locally/",
        "title": "Running Router Chain on Any Local System | Router Docs",
        "content": "Running Router Chain on Any Local System | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInstalling Prerequisites\nRouter CLI\nRunning Router Chain on Any Local System\nGuides\nOn this page\nRunning Router Chain on Any Local System\nIn this section we will dilineate the steps involved in running the Router blockchain on any local machine.\nPart 1: Config File Setup\nâ\nStep 1) Clone the Router Chain repository\nâ\nClone \nthis repo\n to begin deploying the Router Chain in your local system.\nStep 2) Create a config file\nâ\nRun the command given below to create a config file from the existing template.\ncp\n config.example.json config.json\nStep 3) Set the relevant paths and environment\nâ\nIn the \nconfig.json\n file, you will have a key named \nmeta\n.\nSet up the paths for the public key \nrsaPublic\n and the  key \nrsa\n.\nConfig files are picked based on environment. To run locally, set the env to \nlocal\n.\nStep 4) Set the configurations\nâ\nIn the \nconfig.json\n file, there is a list of services supported by the deployment script. Each service has the following fields with default values. You can update the fields as per your requirements.\nname\n - Name of the service\nfn\n - Corresponding handler function (you can see this function in \ndeploy/start.sh\n)\ncontainerName\n - Container name of the service, change it if you want to use a different container name\nsrcPath\n - Local path where to clone the service\nenable\n - Set it to true to start the respective service\nrepo\n - SSH URL of the repository\nbranch\n - Branch of the repo to checkout\nclearCache\n - Set it to true to remove already cloned repository. It will clone the repo again and build it from scratch. Set to false if the repo is already cloned and the docker image is already built. If you are not sure, set it to true.\nExample service config for router-chain:\n{\n    \n\"name\"\n:\n \n\"router-chain\"\n,\n    \n\"fn\"\n:\n \n\"RunChain\"\n,\n    \n\"repo\"\n:\n \n\"git@github.com:router-protocol/router-chain.git\"\n,\n    \n\"branch\"\n:\n \n\"featchain-automation\"\n,\n    \n\"containerName\"\n:\n \n\"router-chain-image\"\n,\n    \n\"srcPath\"\n:\n\"repos/router-chain\"\n,\n    \n\"enable\"\n:\n \nfalse\n,\n    \n\"clearCache\"\n:\n \ntrue\n}\nPart 2: Deployment\nâ\nStep 1) Install the prerequisites\nâ\njq\n - to read the JSON config\ndocker\n - to start containers\nYou can install the aforementioned pre-requisites by following their official documentation or by using the following commands:\napt-get\n \ninstall\n jq\napt-get\n \ninstall\n docker-ce docker-ce-cli containerd.io docker-compose-plugin\nStep 2) Start deployment\nâ\nRun the following commands to start the Router Chain deployment on your local machine:\ncd\n routerchain-devops\nbash\n deploy/start.sh\nOnce these commands are successfully executed, the Router Chain should be running in your local system!\nEdit this page\nPrevious\nRouter CLI\nNext\nGuides\nPart 1: Config File Setup\nPart 2: Deployment\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
    },
        {
            "url": "https://docs.routerprotocol.com//",
            "title": "Router Docs",
            "content": "Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nThe documentation provided below pertains to Router Chain and Router Nitro. For documentation around Router Intents, please refer to the \nfollowing link\n.\nRouter Docs\nThe Router blockchain is a decentralized network built using the Cosmos SDK. Explore our docs and examples to quickly learn, develop & integrate with the Router blockchain.\nGet Started â\nBuild your first iDapp\nBuild your first iDapp (Interoperable dApp) using Router's CrossTalk in 5 simple steps.\niDapp using Stateless bridging\nBuild your first iDapp in 5 steps using Router CrossTalk's stateless bridging.\niDapp using Stateful bridging\nBuild your first Omnichain iDapp in 5 steps using Router CrossTalk's stateful bridging.\nLearn about Router\nWhat is Router?\nThe Router Chain is a layer 1 blockchain that leverages tendermintâs Byzantine Fault Tolerant (BFT) consensus engine.\nChoosing the Right Cross-chain Framework\nRouter Protocol provides a host of cross-chain solutions. Go through this guide to understand which one's right for you.\nThe ROUTE Token\nThe ROUTE token is a digital asset that will serve as the primary gas and governance token on the Router Chain.\nImportant Links\niDapps\nNitro\nAn asset transfer dApp built using Router that facilitates seamless cross-chain swaps.\nStakeEase\nAn omnichain restaking index and restaking aggregator.\nTagzz\nAn omnichain identity / domain name service.\nAuxillary Services\nRouter Explorer\nA block explorer to monitor cross-chain transactions.\nRouter Station\nA tool to manage contract lifecycle-related processes on the Router Chain.\nRouter Faucet\nA platform for users to get Router testnet tokens.\nRouter Hub\nA platform for delegating ROUTE tokens to validators.\nRouter Intent Store\nA place where developers can add their own intent adapters or explore existing ones.\nDevelopers\nð  Build iDapps using Router\nMessage Transfer\nLearn about the instruction transfer framework Crosstalk and convert your existing single/multi-chain applications to cross-chain applications.\nAsset Transfer\nLearn about asset transfer bridge Nitro and how to build other asset-transfer applications or sequenced cross-chain requests (asset + instruction)\nð  Tooling\nRouter Scan\nA feature-rich block explorer for monitoring transactions on the Router Chain.\nRouter Robot\nA cross-chain integration testing framework\nRouter Station\nA web application that makes it easier to interact with the Router Chain.\nRouter Faucet\nGet funds to interact with the Router Chain.\nRelayer\nRun a custom relayer to forward messages from Router to other chains.\nâï¸ Chain Development\nEverything that is needed to learn about development using Router's core components.\nInstalling Prerequisites\nSet up your machine to start developing on the Router Chain\nRouter CLI\nInstall routerd to join the network or simple query it.\nRouter on a Local System\nFollow the steps in this guide to run the Router blockchain on your local machine.\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//overview/",
            "title": "Introduction | Router Docs",
            "content": "Introduction | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nChoosing the Right Cross-chain Framework\nGlossary\nROUTE\nOn this page\nIntroduction\nWhat is Router Chain?\nâ\nThe Router Chain is a layer 1 blockchain that leverages tendermintâs Byzantine Fault Tolerant (BFT) consensus engine. As a Proof of Stake (PoS) blockchain, the Router Chain is primarily run by a network of validators with economic incentives to act honestly. The Router Chain is built using the Cosmos SDK and encapsulates all the features of Cosmos, including fast block times, robust security mechanisms, and, most importantly, CosmWasm - a security-first smart contract platform. By leveraging the CosmWasm toolkit, developers can start building secure blockchain applications on the Router Chain from scratch or port their existing applications to the Router Chain with minimal overhead.\nRouter Chain as an Interoperability Layer\nâ\nIn addition to its functionalities as a blockchain network, the Router Chain provides an innovative\nsolution to the problem of blockchain interoperability. Apart from validating state changes on the Router\nchain, validators running on the Router Chain can also monitor state changes on other chains. Applications\non the Router Chain can write custom logic to trigger events in response to these external state changes.\nAdditionally, applications on the Router Chain can leverage a trustless network of relayers to update\nstates on external chains. Simply put, the Router architecture allows contracts on one chain to interact\nwith contracts on other chains in a secure and decentralized manner. \nCommunication via Router CrossTalk\nâ\nRouter's CrossTalk library is an extensible cross-chain framework that enables seamless state transitions across multiple chains. In simple terms, this library abstracts Router's functionalities to allow contracts on one chain to pass instructions to contracts deployed on some other chain. The library is structured in a way that it can be integrated seamlessly into your development environment to allow for cross-chain message passing without disturbing other parts of your product. \nCrossTalk supports both stateful and stateless bridging:\nFor cross-chain dApps that require custom bridging logic between any two chains, developers can build and deploy middleware contracts on the Router Chain. All cross-chain requests originating from the dApp's source chain contract will come to this middleware contract where some actions can be performed before they are forwarded to the intended destination chain.\nFor dApps that do not require any custom bridging logic or any data aggregation layer in the middle, no middleware contract is required. \nGlobal Liquidity via Nitro\nâ\nNitro is a cross-chain swapping engine that allows for cross-chain asset transfers as well as cross-chain sequencing of asset transfers and arbitrary instruction transfers. Nitro has a whole development suite around it, which includes:\na widget that can be used by other projects to give their users an option to perform cross-chain transactions directly from their UI;\nan API and a SDK that abstracts Nitro's backend capabilities for projects that want to use their own UI/platform for offering the cross-chain asset swap functionality;\nmost importantly, the sequencer library, which allows developers to build cross-chain applications that require both asset transfer and instruction transfer in a single cross-chain request.\nEdit this page\nNext\nChoosing the Right Cross-chain Framework\nWhat is Router Chain?\nRouter Chain as an Interoperability Layer\nCommunication via Router CrossTalk\nGlobal Liquidity via Nitro\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//router-core/",
            "title": "Introduction | Router Docs",
            "content": "Introduction | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInstalling Prerequisites\nRouter CLI\nRunning Router Chain on Any Local System\nGuides\nOn this page\nIntroduction\nThe guides in this section will explain the process of developing using Router's core components.\nGet Started\nâ\nDevelopers\nInstalling Prerequisites\nSetting up the machine for developing on the Router Chain\nRouter CLI\nInstall routerd to join the network or simple query it\nRouter on a Local System\nRun the Router blockchain on your local machine\nGuides\nYour First Contract\nLearn how to compile and deploy your first CosmWasm contract on the Router Chain\nEdit this page\nNext\nInstalling Prerequisites\nGet Started\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//develop/",
            "title": "Introduction | Router Docs",
            "content": "Introduction | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nMessage Transfer via CrossTalk\nAsset Transfer via Nitro\nOn this page\nIntroduction\nThe guides on this page will explain the process of developing via Router's CrossTalk and Nitro. The CrossTalk framework\nleverages Router's infrastructure to allow contracts on one chain to send intructions to contracts deployed on some other chain. On the other hand,\nNitro is the native cross-chain asset-transfer bridge built using Router. It acts as the gateway to the liquidity managed by Router Protocol and allows\nprojects to execute cross-chain transactions which involve both fund transfer and instruction transfer.\nIf you're new here or you're not sure if CrossTalk is compatible with your requirements, check out \nthis guide\n to figure out\nthe best cross-chain framework for your dApp.\nMessage Transfer via CrossTalk\nâ\nTheoretical Concepts\nOverview\nWhat is CrossTalk why is it required?\nUnderstanding Message transfer\nDissecting different functions and parameters associated with CrossTalk\nFee Management\nGaining a deeper understanding of how the CrossTalk and Omnichain Fee is computed\nGuides\nEVM Guides\nLearning how to execute different types of cross-chain requests in EVM Chains\nNEAR Guides\nLearning how to execute different types of cross-chain requests in NEAR\nRouter Chain Guides\nLearning how to execute different types of cross-chain requests from or to Router Chain\nSample iDapps\nDeploying a Cross-chain Ping Pong Contract\nLearn how to deploy your first cross-chain dApp using Router's CrossTalk framework\nDeploying a Cross-chain NFT (ERC-1155)\nLearn how to deploy a cross-chain NFT using Router's CrossTalk framework\nUnderstanding Functions\nEVM\nUnderstanding the crosstalk functions for EVM contracts\nNEAR\nUnderstanding the crosstalk functions for Near chain\nRouter Chain\nUnderstanding the crosstalk functions for Router Chain\nAsset Transfer via Nitro\nâ\nDevelopers\nOverview\nWhat is Nitro and how is it different from Voyager?\nRouter Nitro\nUnderstanding the architecture of Nitro\nDevelopers\nNitro Widget\nWidget to integrate cross-chain swaps on your website\nNitro PathFinder API\nAn API to integrate Voyager's cross-chain swap functionality\nMigrating from Voyager to Nitro\nGuide to help users migrate from Voyager to Nitro\nGuides\nDeploying a Cross-chain Staking Contract using Nitro\nLearn how to deploy your first cross-chain staking dApp using Nitro\nBuilding a Cross-chain Token using Router\nLearn how to deploy a cross-chain token using Router\nCross-chain Transfer/Swap APIs\nAPI endpoints\nNitro Pathfinder API endpoints\nGetting Started\nHow to interact with Pathfinder API\nEdit this page\nNext\nMessage Transfer via Crosstalk\nMessage Transfer via CrossTalk\nAsset Transfer via Nitro\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//router-pay/",
            "title": "Introduction | Router Docs",
            "content": "Introduction | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nIntegrating Router Pay\nUser Journey with Router Pay\nTechnical Specifications\nBenefits\nIntroduction\nRouter Pay introduces the Instruction Specific Address (ISA) mechanism, which enables wallet-less interactions with decentralized applications (DApps). By generating dynamic, single-use addresses, users can initiate transactions by transferring assets directly, without wallet connections or approvals. The ISA mechanism supports both single-chain and cross-chain interactions, enhancing user security and convenience while bringing a familiar Web 2.0 experience to Web 3.0 applications, including use cases like POS machines for merchant payments.\nMotivation\nCurrently, DApp interactions in Web 3.0 often require wallet connections and approvals, introducing additional steps that disrupt usability and pose security risks. This complex flow has hindered DeFi adoption, as Web 3.0 interfaces donât match the ease and familiarity of Web 2.0 experiences, especially compared to centralized exchanges.\nRouter Pay (referred to as ISA as well) addresses these issues by offering a user journey that mirrors the simplicity of Web 2.0 actions. With Router Pay, users can complete interactions by simply scanning a QR code and sending payment. This approach enables a seamless, recognizable process, supporting a Web 2.0-like user experience in a Web 3.0 setting. By bridging the usability gap between centralized and decentralized applications, Router Pay opens the door for greater mainstream adoption of DeFi.\nLearn about Router Pay\nUser Journey with Router Pay\nLearn about the advanced user journey with Router Pay\nTechnical Specifications\nHow does Router Pay work technically\nBenefits\nBenefits of Router Pay\nIntegrating Router Pay\nAPI endpoints\nRouter Pay API endpoints\nAdd ISA to your dApp\nIntegrate Router Pay and provide a no sign-up UX to users\nNitro integration via Router Pay\nIntegrate Router Nitro with no sign-up flow for users\nEdit this page\nNext\nIntegrating Router Pay\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//tooling/",
            "title": "Introduction | Router Docs",
            "content": "Introduction | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInfrastructure\nUtilities\nRelayers\nNitro Forwarders\nOn this page\nIntroduction\nThe guides in this section will explain the process of using various tools to simplify building and maintaining dApps using Router.\nImportant Tools\nâ\nRouter Explorer\nA block explorer to monitor cross-chain transactions.\nRouter Faucet\nA tool to get testnet tokens for performing tasks on Testnet.\nRouter Station\nA tool to manage contract lifecycle-related processes on the Router Chain.\nRouter Hub\nA tool for delegating ROUTE tokens to validators.\nRouter Sandbox\nAn easy-to-use prototyping environment for interoperable dApps built using Router.\nInfrastructure\nâ\nRouter Scan\nA block explorer for projects to monitor their cross-chain transactions\nRouter Station\nA tool to manage contract lifecycle-related processes on the Router Chain\nRouter Robot\nA cross-chain integration testing framework\nRouter Sandbox\nAn easy-to-use prototyping environment for interoperable dApps built using Router\nUtilities\nâ\nGolang SDK\nA Go SDK to interact with the Router Chain\nTypescript SDK\nA TS SDK to interact with the Router Chain\nRouter Wasm Bindings\nA Rust crate consisting of wasm bindings to create contracts on the Router Chain\nRelayers\nâ\nOverview\nBasics about relayers on the Router Chain\nRelayer Guide\nSteps involved in running a relayer\nEdit this page\nNext\nInfrastructure\nImportant Tools\nInfrastructure\nUtilities\nRelayers\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//networks/",
            "title": "Public Endpoints | Router Docs",
            "content": "Public Endpoints | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nPublic Endpoints\nSupported Chains\nTools\nOn this page\nPublic Endpoints\nThe following APIs are recommended for development purposes.\nOfficial Public Endpoints\nâ\nNetwork\nMainnet\nTestnet\nChain ID\nrouter_9600-1\nrouter_9601-1\nRPC\nhttps://sentry.evm.rpc.routerprotocol.com\nhttps://evm.rpc.testnet.routerchain.dev\ngRPC-gateway\nhttps://sentry.grpcweb.routerprotocol.com\nhttps://grpc.testnet.routerchain.dev\nTM endpoint\nhttps://sentry.tm.rpc.routerprotocol.com\nhttps://tm.rpc.testnet.routerchain.dev\nLCD endpoint\nhttps://sentry.lcd.routerprotocol.com\nhttps://lcd.sentry.routerchain.dev\nFaucet UI\n-\nhttps://faucet.routerprotocol.com\nExplorer UI\nhttps://routerscan.io\nhttps://testnet.routerscan.io\nExplorer endpoint\nhttps://api.explorer.routerscan.io\nhttps://explorer-api.testnet.routerchain.dev\nExplorer WSS endpoint\nwss://api.explorer.routerscan.io\nwss://explorer-api.testnet.routerchain.dev\nEdit this page\nNext\nSupported Chains\nOfficial Public Endpoints\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//validators/",
            "title": "Overview | Router Docs",
            "content": "Overview | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nOverview\nOrchestrators\nPoS Validation\nSupported Networks\nRunning a Validator\nDelegating ROUTE Tokens to Participate in Staking\nSlashing Conditions\nOverview\nValidators are nodes that participate in the security of a network by verifying and committing new blocks in the blockchain. Like other Cosmos-based chains, validators on the Router Chain are expected to mine blocks in exchange for block rewards. However, validators on the Router Chain are tasked with another responsibility - running an orchestrator instance. Before reading more about orchestrators, it is important to understand the \nhigh-level workflow\n of a cross-chain transaction via Router.\nEdit this page\nNext\nOrchestrators\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//discover/",
            "title": "Discover iDapps and Tools | Router Docs",
            "content": "Discover iDapps and Tools | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nDiscover iDapps and Tools\nOn this page\nDiscover iDapps and Tools\nThis section provides an overview of the different iDapps developed using Router's infrastructure. Additionally, you can access essential tools required for interacting with Router's infrastructure.\niDapps\nâ\nNitro\nAn asset transfer dApp built using Router that facilitates seamless cross-chain swaps.\nStakeEase\nAn omnichain restaking index and restaking aggregator.\nTagzz\nAn omnichain identity / domain name service.\nTools\nâ\nRouter Explorer\nA block explorer to monitor cross-chain transactions.\nRouter Station\nA tool to manage contract lifecycle-related processes on the Router Chain.\nRouter Faucet\nA platform for users to get Router testnet tokens.\nRouter Hub\nA platform for delegating ROUTE tokens to validators.\nRouter Intent Store\nA place where developers can add their own intent adapters or explore existing ones.\nEdit this page\niDapps\nTools\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//brand-assets/",
            "title": "Brand Assets | Router Docs",
            "content": "Brand Assets | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nBrand Assets\nRouter Brand Assets\nNitro Brand Assets\nBrand Assets\nWelcome to the Router Protocol Brand Kit!\nHere, you'll find all the assets and logos you need to represent Router Protocol consistently and accurately across all mediums. Our goal is to enable builders to create seamless, user-friendly chain abstracted dApps that connect all chains, and our branding reflects that vision of simplicity and connectivity.\nBelow are the brand assets for both Router Protocol and Nitro.\nRouter Brand Assets\nNitro Brand Assets\nEdit this page\nNext\nRouter Brand Assets\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//develop/message-transfer-via-crosstalk/evm-guides/your-first-crosschain-nft-contract/",
            "title": "Your First iDapp | Router Docs",
            "content": "Your First iDapp | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nMessage Transfer via CrossTalk\nOverview\nKey Concepts\nEVM Guides\niDapp Functions\nBuild your first Cross-Chain NFT contract\nCreating a Sample Cross-Chain NFT Contract\nDeploying a Sample Cross-Chain NFT Contract\nCross-chain Read Requests\nASM Implementation\nNEAR Guides\nRouter Chain Guides\nSolana Guides\nStateful (OmniChain) Bridging\nSample iDapps\nHelpful Repositories\nAsset Transfer via Nitro\nYour First iDapp\nIn this section, we'll provide a step-by-step guide for how users can deploy their first iDapp using the Crosstalk framework.\nThe iDapp end-to-end development is a simple 5 step process. It has been broken down into 2 parts -\nCreating your cross-chain NFT contract\nDeploying and testing your NFT contract\nEdit this page\nPrevious\nsetDappMetadata\nNext\nCreating a Sample Cross-Chain NFT Contract\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//develop/message-transfer-via-crosstalk/stateful-bridging/your-first-omnichain-dapp/",
            "title": "Your First OmniChain dApp | Router Docs",
            "content": "Your First OmniChain dApp | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nMessage Transfer via CrossTalk\nOverview\nKey Concepts\nEVM Guides\nNEAR Guides\nRouter Chain Guides\nSolana Guides\nStateful (OmniChain) Bridging\nYour First Omnichain dApp\n1) Setting up Router's EVM Tesnet\n2) Deploying a Sample Application Contract\n3) Deploying a Sample Bridge Contract\nStateful vs Stateless Bridging\nBenefits\nHigh Level Architecture\nTexchange\nSample iDapps\nHelpful Repositories\nAsset Transfer via Nitro\nYour First OmniChain dApp\nIn this section, we'll provide a step-by-step guide for how users can deploy their first cross-chain dApp that leverages the middleware infra enabled by the Router Chain.\nBefore diving into the guide, it's important to understand Router's \nhigh-level architecture\n. Once you have gained a basic understanding of how a cross-chain application works on the Router Chain, you can read through this guide that will cover the following sections:\nSetting up Router's EVM Devnet to deploy and test sample cross-chain applications\nDeploying a sample application contract (Solidity) on Router's EVM Devnet\nDeploying a sample bridge contract (CosmWasm) on Router's Alpha Devnet\nAt the end of the guide, we'll have two working contracts:\nAn application contract on Router's EVM Devnet acting as both the source and destination contract\nA bridge contract on the Router Chain\nEdit this page\nPrevious\nStateful (OmniChain) Bridging\nNext\n1) Setting up Router's EVM Tesnet\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//overview/choosing-the-right-framework/",
            "title": "Choosing the Right Cross-chain Framework | Router Docs",
            "content": "Choosing the Right Cross-chain Framework | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nChoosing the Right Cross-chain Framework\nGlossary\nROUTE\nOn this page\nChoosing the Right Cross-chain Framework\nRouter Protocol provides two ways using which developers can build cross-chain applications, namely -\nCrossTalk framework (stateless and stateful communication)\nNitro (leveraging global liquidity with message transfers)\nLet us now understand which framework best suits your requirements before using it in your dApp. \nCrossTalk Framework\nâ\nStateless\nâ\nFor standard cross-chain instruction transfers, CrossTalk framework is the best option. It is an easy-to-implement cross-chain smart contract library that can convert your existing multi-chain applications to cross-chain applications. CrossTalk's ability to transfer multiple contract-level instructions in a single cross-chain call makes it a very powerful tool. Various dApps like cross-chain NFTs (burning an NFT on one chain and minting it on another) and cross-chain lending/borrowing applications (enabling a borrower to provide collateral on one chain and then transferring an instruction to mint/unlock the borrower's desired token on the destination chain) can be built using this framework.\nStateful\nâ\nIf an application does not require any logic in the middle or does not need any accounting layer, CrossTalk's generic workflow can be used. However, if you want to build an application that requires custom bridging logic or a decentralized accounting layer, you can use CrossTalk's stateful bridging. For example, you can use stateful bridging to create a multi-chain NFT collection with a single place to maintain the list of all the NFTs minted on different chains. If you wanted to use existing solutions, you'd have to maintain this list on all the chains where your dApp is deployed. In this case, by removing the redundancy involved in accounting, a CosmWasm contract on the Router Chain act as a data aggregation layer. Another potential dApp that can benefit from Router's middleware capabilities is a cross-chain DEX. You'll need to deploy the token-swapping logic only on the Router Chain, while smart contracts on other chains only need to include the locking/unlocking logic. \nNitro\nâ\nNitro (previously Voyager) is the native cross-chain asset-transfer bridge built on Router. It acts as the gateway to the liquidity managed by Router Protocol. Developers can use Nitro to access this liquidity and build either (a) other asset-transfer applications or (b) applications requiring both an asset transfer and an instruction transfer in a single sequenced cross-chain request. A very good example of the latter is a cross-chain staking application that needs to transfer users' funds and an instruction to stake them in a particular contract, both in a single cross-chain request.\nEdit this page\nPrevious\nIntroduction\nNext\nGlossary\nCrossTalk Framework\nNitro\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//overview/route/",
            "title": "ROUTE | Router Docs",
            "content": "ROUTE | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nChoosing the Right Cross-chain Framework\nGlossary\nROUTE\nOn this page\nROUTE\nRouter Protocol's native cryptographically-secured digital token ROUTE is a transferable representation of a functional asset that will be used as the gas and governance token in the Router ecosystem. \nUtility\nâ\nROUTE will initially be used for the following (although governance is free to add or remove these functions):\nGovernance\nâ\nThe holders of the ROUTE token will be able to use their tokens to decide the future of the protocol by voting on Router's governance proposals. Active stakeholders of the network will be responsible for proposing, vetting, and passing proposals concerning protocol amendments and upgrades.\nGas Currency\nâ\nROUTE token will be used as the native token on the Router Chain. \nValidator Incentives\nâ\nBlock rewards to the validators will be paid out in ROUTE tokens.\nCrossTalk Fees\nâ\nROUTE token will be used as a fee token in Routerâs CrossTalk framework.\nEdit this page\nPrevious\nGlossary\nUtility\nGovernance\nGas Currency\nValidator Incentives\nCrossTalk Fees\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//develop/message-transfer-via-crosstalk/",
            "title": "Message Transfer via Crosstalk | Router Docs",
            "content": "Message Transfer via Crosstalk | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nMessage Transfer via CrossTalk\nOverview\nKey Concepts\nEVM Guides\nNEAR Guides\nRouter Chain Guides\nSolana Guides\nStateful (OmniChain) Bridging\nSample iDapps\nHelpful Repositories\nAsset Transfer via Nitro\nMessage Transfer via Crosstalk\nThis section of the documentation will provide an in-depth view of the CrossTalk framework.\nTheoretical Concepts\nOverview\nWhat is CrossTalk why is it required?\nKey Concepts\nDissecting different functions and parameters associated with CrossTalk\nFee Management\nGaining a deeper understanding of how the CrossTalk and Omnichain Fee is computed\nGuides\nEVM-Guides\nLearning how to execute different types of cross-chain requests in EVM Chains\nNEAR-Guides\nLearning how to execute different types of cross-chain requests in NEAR\nSolana-Guides\nLearning how to execute different types of cross-chain requests from or to Solana\nRouter-chain-Guides\nLearning how to execute different types of cross-chain requests from or to Router Chain\nSample iDapps\nDeploying a Cross-chain Ping Pong Contract\nLearn how to deploy your first cross-chain dApp using Router's CrossTalk framework\nDeploying a Cross-chain NFT (ERC-1155)\nLearn how to deploy a cross-chain NFT using Router's CrossTalk framework\nUnderstanding Functions\nEVM Guide\nUnderstanding the crosstalk functions for EVM contracts\nNEAR Guide\nUnderstanding the crosstalk functions for Near chain\nSolana Guide\nUnderstanding the crosstalk functions for Solana\nRouter Chain Guide\nUnderstanding the crosstalk functions for Router Chain\nEdit this page\nPrevious\nIntroduction\nNext\nOverview\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//tooling/infra/router-scan/",
            "title": "RouterScan | Router Docs",
            "content": "RouterScan | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInfrastructure\nRouter Scan\nFetch data using GQL Playground\nFetch data using JS\nApplication-specific Explorer\nRouter Station\nRouter Sandbox\nRouter Robot\nUtilities\nRelayers\nNitro Forwarders\nOn this page\nRouterScan\nOverview\nâ\nThe Router explorer provides information on the blocks, validator, network status, and various types of transactions happening on Router Chain. We have provided an easy way using GraphQL to query the Router Chainâs explorer data so that developers and applications can use the data as per their requirements for analytics or creating their own custom explorer.\nAPI Endpoints\nâ\nHere all requests are READ ONLY. As of now there are no updates on DB available using these APIs. There are multiple endpoints provided, which can be used to get the desired data.\nExplorer DBâs data can be queried with the GraphQL endpoints as given below. For application specific use cases refer \nApplication specific explorer\n \nIn case of a requirement to directly use the functions to get data rather than a query, \nsdk-ts\n can be used. The SDK has all the necessary function to query data from the explorer DB.\nEdit this page\nPrevious\nInfrastructure\nNext\nFetch data using GQL Playground\nOverview\nAPI Endpoints\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//tooling/infra/router-robot/",
            "title": "Overview | Router Docs",
            "content": "Overview | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInfrastructure\nRouter Scan\nRouter Station\nRouter Sandbox\nRouter Robot\nOverview\nUsage\nUtilities\nRelayers\nNitro Forwarders\nOn this page\nOverview\nWhat is Router Robot?\nRouterRobot is a cross-chain integration testing framework for end-to-end testing, behavior-driven development (BDD), and robotic process automation (RPA). The framework has a rich ecosystem around it consisting of various generic libraries and tools that are developed to ease e2e testing of cross-chain applications built on the Router Chain.\nWhy Router Robot?\nâ\nEnables easy-to-use tabular syntax for \ncreating test cases\n in a uniform way.\nProvides ability to create reusable \nhigher-level keywords\n from existing keywords.\nProvides easy-to-read result \nreports\n and \nlogs\n in HTML format.\nIs platform and application independent.\nProvides a simple \nlibrary API\n for creating customized test libraries that can be implemented natively with Python.\nProvides a \ncommand line interface\n and XML-based \noutput files\n for integration into existing build infrastructure (continuous integration systems).\nProvides support for testing web applications, rest APIs, mobile applications, running processes, connecting to remote systems via Telnet or SSH, and so on.\nSupports creating \ndata-driven test cases\n.\nHas built-in support for \nvariables\n, practical, particularly for testing in different environments.\nProvides \ntagging\n to categorize and \nselect test cases\n to be executed.\nEnables easy integration with source control: \ntest suites\n are just files and directories that can be versioned with the production code.\nProvides \ntest-case\n and \ntest-suite-level\n setup and teardown.\nEdit this page\nPrevious\nRouter Robot\nNext\nUsage\nWhy Router Robot?\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//tooling/infra/router-station/",
            "title": "Router Station | Router Docs",
            "content": "Router Station | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInfrastructure\nRouter Scan\nRouter Station\nRouter Sandbox\nRouter Robot\nUtilities\nRelayers\nNitro Forwarders\nOverview\nRouter Station is the official tool of the Router Chain. It helps with wallet management, cosmwasm contract deployment, execution, queries, and other contract lifecycle-related processes.\nTo deploy a smart contract on the Router Chain there is a requirement to create a wasm build of the smart contract. \nPlease refer to the following document to learn how to create the wasm build.\n1. Add a Router Account on the Router Station\nTo use the Router Station UI for any operation related to the contract life-cycle process( except the contract read query), you need to have at least one account added in the Router Station. To add an account in the Router Station, you need to follow the below mentioned steps or you can also follow the video. \nClick on the âAdd Accountâ button\nIn the pop-up, fill the âLabelâ & âMnemonicâ text areas. You can also click on the refresh button to get a new Mnemonic.\nNow, click on the âAddâ button. and your account is added to the Router Station.\nYou can follow the same process for multiple accounts here.\n2. Add an existing smart contract\nYou can add an existing cosmwasm contract in the Router Station. To add an existing contract address, you need to click on the â+Add contractâ button.  A pop-up shows up. The router contract address can be added in the Import contract text field and can be imported for further action.\n3. Upload wasm Contract\nThe Router Chain is a cosmos chain. To deploy a smart contract first, you need to upload the contractâs wasm file on the chain. On Router Station to upload a wasm file, you need to follow the below mentioned steps or you can also follow the video. \nClick on the â+Add Contractâ button. It will open up one pop-up.\nHere, you need to select the wasm file.\nThen click on the âUpload Onlyâ button.\nOnce the upload button is clicked an \nUploading Contract\n toast msg can be seen, which signifies that the contract upload is happening in the background.\nAfter the successful transaction, a success toast message can be seen with the \nUploaded code Id\n to the right. \n4. Upload wasm contract and Instantiate\nIn Router Chain, you can create a new contract by instantiating a deployed code id. If you donât have a deployed code id preset then you can deploy and instantiate the contract otherwise instantiate the contract by using the existing deployed code id.\nYou provide both functionalities on the Router Station. \nTo deploy and instantiate a smart contract first, you need to follow the below mentioned steps or you can also follow the video. \nClick on the â+Add Contractâ button. It will open up one pop-up.\nFirst, you need to select the âFrom fileâ radio button.\nYou need to fill the âLabelâ text box and instantiate the message.\nThe admin field is optional. If it is empty our admin will be null and that makes the contract immutable.\nHere, you also need to select the wasm file.\nThen click on the âUpload and Instantiateâ button.\nOnce the upload and instantiate button is clicked upon, an \nUploading Contract\n toast message can be seen. This signifies that the uploading of the contract is happening in the background.\nRight after uploading is successful, the uploaded contractâs code id and instantiating contract toast msg can be seen. This signifies that the instantiation of the contract is happening in the background. \nAfter successful instantiation of the contract, a success toast with the instantiated contract address can be seen, in it to the right and that particular contract added on to the left side under the Contracts section can be seen.\n5. Execute transaction  and Query operation on the added contract\nA cosmwasm contract has multiple execute or query messages. The execute message can read and write the contract states, but the query messages can only read contract storage. That is why to perform execute messages you need to have a user account, but not for the query messages.\nIn the Router station, you need to select one contract on which you want to perform the operation. Then you can write down the JSON query in the text section as shown in the video. Now, according to the query type you can hit either the âExecuteâ or the âqueryâ button.  The output will be shown in the right section of the query.\nPlease check out the video, In this video, you performed the message execution and query for the Counter contract. link?\n6. Contract Migration\nCosmwasm contracts can be upgraded. To upgrade a cosmwasm smart contract, you need to satisfy two conditions. The contract should support migration and its admin address should not be null. To migrate the contract, you need to follow the below mentioned steps or you can also follow the video. \nSelect the contract that needs to be migrated.\nClick on the âMigrate Contractâ button. It will open one pop-up.\nProvide the new code id and the âmigration messageâ.\nNow, Click on the âmigrateâ button. It will submit the migration message on the chain.\nUpon, the successful transaction you will able to see the updated code id in the contract info section.\n7. Contract Admin Update\nCosmwasm contracts have an admin address. It is provided at the time of instantiation of the contract. It decides the contractâs immutability. If it is null, the contact is immutable. \nTo update the contractâs admin address, you need to follow the below mentioned steps or you can also follow the video. \nSelect the contract that needs to be updated.\nClick on the âUpdate Adminâ button. It will open one pop-up.\nProvide the new admin address or leave it empty( if you want to set the admin address to null).\nNow, Click on the âupdateâ button. It will submit the update admin message on the chain.\nUpon, the successful transaction you will able to see the updated admin address in the contract info section.\nEdit this page\nPrevious\nUsage\nNext\nRouter Sandbox\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//tooling/relayers/",
            "title": "Overview | Router Docs",
            "content": "Overview | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInfrastructure\nUtilities\nRelayers\nOverview\nRelayer Guide\nNitro Forwarders\nOn this page\nRelayers\nBasics about relayers on the Router Chain\nIntro to Router Relayers\nâ\nIn the Router system, relayers are permissionless entities that relay executable proposals from the Router Chain to a specific\ndestination chain. The Router Chain has a set of relayers operated by various third parties, which distributes the\nresponsibility. In the set, each relayer listens to the Router Chain and relays data to the\ndestination chains as and when required. These relayers also carry out subsequent actions based on the\nevents that have been transmitted.\nFunctionalities\nâ\nThe relayer will be able to submit outbound/crosstalk requests to the destination chain.\nThe relayer will be able to whitelist application bridge contract addresses and process only outbound requests originating from the whitelisted application bridge contract addresses.\nThe relayer will be able to submit a ValsetUpdate request to all the destination chains configured\non the multichain module.\nThe relayer will be able to secure the keys of various chain types - EVM, Cosmos, and Substrate,\namong others.\nEdit this page\nPrevious\nRelayers\nNext\nRelayer Guide\nIntro to Router Relayers\nFunctionalities\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//router-core/installing-prerequisites/",
            "title": "Installing Prerequisites | Router Docs",
            "content": "Installing Prerequisites | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInstalling Prerequisites\nRouter CLI\nRunning Router Chain on Any Local System\nGuides\nOn this page\nInstalling Prerequisites\nInstall Go\nâ\nIf you do not have Go installed in your system, you can set it up by following the three easy steps listed \nhere\n. The latest versions of \nrouterd\n require Go version \nv1.18+\n.\nSet up Rust\nâ\nTo work with CosmWasm, you'll need to make sure you have \nrustup\n installed along with a recent \nrustc\n and \ncargo\n version installed. Currently, we are testing on \n1.58.1+\n. We use \nrustup\n to install rust since it makes maintaining dependencies and handling updates much more efficient.\nInstalling Rust on Mac/Linux\nStep 1)\n Install \nrustup\n.\nStep 2)\n Once installed, check that you have the correct version installed:\nrustup default stable\ncargo version\n# If this is lower than 1.58.1+, update\nrustup update stable\nStep 3)\n Once rust is installed, make sure you have the \nwasm32\n target:\nrustup target list --installed\n# if wasm32 is not listed after running the aforementioned command, run the following:\nrustup target \nadd\n wasm32-unknown-unknown\nInstalling Rust on Windows 10\nStep 1)\n Download and execute \nrustup-init.exe\n from \nrustup.rs\n.\nIf prompted, download and install Visual C++ Build Tools 2019, from \nhttps://visualstudio.microsoft.com/visual-cpp-build-tools/\n. Make sure \"Windows 10 SDK\" and \"English language pack\" are selected.\nStep 2)\n Once installed, check that you have the correct version installed:\nrustup default stable\ncargo version\n# If this is lower than 1.58.1+, update\nrustup update stable\nStep 3)\n Once rust is installed, make sure you have the \nwasm32\n target:\nrustup target list --installed\n# if wasm32 is not listed after running the aforementioned command, run the following:\nrustup target \nadd\n wasm32-unknown-unknown\nIDE\nâ\nTo develop and test smart contracts using Rust, a good IDE is a must. Currently, \nVSCode\n is the best-supported environment for RLS (Rust Language Server). Coupled with the \nrust-analyzer for the VSCode\n plugin, it makes use of the rust compiler to type-check all your code on each save.\nDocker\nâ\nTo optimize production code and make the binary size of compiled CosmWasm contracts as small as possible, we use \nrust-optimizer\n, which uses Docker to work. Download and install Docker Desktop for your system using this \nlink\n.\nEdit this page\nPrevious\nIntroduction\nNext\nRouter CLI\nInstall Go\nSet up Rust\nIDE\nDocker\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//router-core/routerd/",
            "title": "Router CLI | Router Docs",
            "content": "Router CLI | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInstalling Prerequisites\nRouter CLI\nRunning Router Chain on Any Local System\nGuides\nOn this page\nrouterd\nrouterd\n is the command-line interface and daemon that connects to Router and enables you to interact with the Router Chain. Router Core is the official Golang reference implementation of the Router node software.\nQuick Start\nâ\nTo install \nrouterd\n and interact with the Router Core without running a node, run the following commands on your terminal/cmd:\ngit\n clone https://github.com/router-protocol/router-chain.git\n//router-chain.git is a private repo as of now, please request access \nfor\n the same via discord\ncd\n router-chain\ngit\n checkout dev\nmake\n \ninstall\nVerify the installation by running the following command:\nrouterd version\nTroubleshooting Common Issues\nIf you are on a Windows machine and the \nmake\n software is not preinstalled, install it using the instructions given \nhere\n.\nIf you get the following error while cloning the router-chain git repo: \nremote: Support for password authentication was removed on August 13, 2021\n then follow the steps given \nhere\n to resolve it.\nIf you get the following error while running \nmake install\n on your Mac: \nxcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun\n then follow the steps given \nhere\n to resolve it.\nmake install\n will copy \nrouterd\n to \n$HOME/go/bin\n by default. If you get the following error: \nzsh: command not found: routerd\n then add the following two commands to the ~/.zshrc file:\nexport\n \nGOPATH\n=\n$HOME\n/go\nexport\n \nPATH\n=\n$GOPATH\n:\n$GOPATH\n/bin:\n$PATH\nTo find the ~/.zshrc file, go to Finder -> Home (your Mac user account) and unhide hidden files by pressing \ncmd\n + \nshift\n + \n.\n simultaneously.\nEdit this page\nPrevious\nInstalling Prerequisites\nNext\nRunning Router Chain on Any Local System\nQuick Start\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        },
        {
            "url": "https://docs.routerprotocol.com//router-core/running-router-chain-locally/",
            "title": "Running Router Chain on Any Local System | Router Docs",
            "content": "Running Router Chain on Any Local System | Router Docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSkip to main content\nOverview\nRouter Core\nDevelop\nRouter Pay\nTooling\nNetworks\nValidators\nDiscover\nAudits\nBrand Assets\nIntroduction\nInstalling Prerequisites\nRouter CLI\nRunning Router Chain on Any Local System\nGuides\nOn this page\nRunning Router Chain on Any Local System\nIn this section we will dilineate the steps involved in running the Router blockchain on any local machine.\nPart 1: Config File Setup\nâ\nStep 1) Clone the Router Chain repository\nâ\nClone \nthis repo\n to begin deploying the Router Chain in your local system.\nStep 2) Create a config file\nâ\nRun the command given below to create a config file from the existing template.\ncp\n config.example.json config.json\nStep 3) Set the relevant paths and environment\nâ\nIn the \nconfig.json\n file, you will have a key named \nmeta\n.\nSet up the paths for the public key \nrsaPublic\n and the  key \nrsa\n.\nConfig files are picked based on environment. To run locally, set the env to \nlocal\n.\nStep 4) Set the configurations\nâ\nIn the \nconfig.json\n file, there is a list of services supported by the deployment script. Each service has the following fields with default values. You can update the fields as per your requirements.\nname\n - Name of the service\nfn\n - Corresponding handler function (you can see this function in \ndeploy/start.sh\n)\ncontainerName\n - Container name of the service, change it if you want to use a different container name\nsrcPath\n - Local path where to clone the service\nenable\n - Set it to true to start the respective service\nrepo\n - SSH URL of the repository\nbranch\n - Branch of the repo to checkout\nclearCache\n - Set it to true to remove already cloned repository. It will clone the repo again and build it from scratch. Set to false if the repo is already cloned and the docker image is already built. If you are not sure, set it to true.\nExample service config for router-chain:\n{\n    \n\"name\"\n:\n \n\"router-chain\"\n,\n    \n\"fn\"\n:\n \n\"RunChain\"\n,\n    \n\"repo\"\n:\n \n\"git@github.com:router-protocol/router-chain.git\"\n,\n    \n\"branch\"\n:\n \n\"featchain-automation\"\n,\n    \n\"containerName\"\n:\n \n\"router-chain-image\"\n,\n    \n\"srcPath\"\n:\n\"repos/router-chain\"\n,\n    \n\"enable\"\n:\n \nfalse\n,\n    \n\"clearCache\"\n:\n \ntrue\n}\nPart 2: Deployment\nâ\nStep 1) Install the prerequisites\nâ\njq\n - to read the JSON config\ndocker\n - to start containers\nYou can install the aforementioned pre-requisites by following their official documentation or by using the following commands:\napt-get\n \ninstall\n jq\napt-get\n \ninstall\n docker-ce docker-ce-cli containerd.io docker-compose-plugin\nStep 2) Start deployment\nâ\nRun the following commands to start the Router Chain deployment on your local machine:\ncd\n routerchain-devops\nbash\n deploy/start.sh\nOnce these commands are successfully executed, the Router Chain should be running in your local system!\nEdit this page\nPrevious\nRouter CLI\nNext\nGuides\nPart 1: Config File Setup\nPart 2: Deployment\nRouter Protocol\nHome\nNitro\nNitro Explorer\nIntent Store\nIntent PoCs\nEcosystem\nResources\nRouter Chain Whitepaper\nRouter CCIF Whitepaper\nGitHub\nMedium\nCareers\nBrand Assets\nSocials\nTwitter\nTelegram\nDiscord\nYouTube\nLinkedIn\nCopyright Â© Router Protocol since 2021. All rights reserved.."
        }
    ]